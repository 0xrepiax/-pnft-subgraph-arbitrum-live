// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ChartTrade extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ChartTrade entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChartTrade must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChartTrade", id.toString(), this);
    }
  }

  static load(id: string): ChartTrade | null {
    return changetype<ChartTrade | null>(store.get("ChartTrade", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get interval(): i32 {
    let value = this.get("interval");
    return value!.toI32();
  }

  set interval(value: i32) {
    this.set("interval", Value.fromI32(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get open(): BigDecimal {
    let value = this.get("open");
    return value!.toBigDecimal();
  }

  set open(value: BigDecimal) {
    this.set("open", Value.fromBigDecimal(value));
  }

  get close(): BigDecimal {
    let value = this.get("close");
    return value!.toBigDecimal();
  }

  set close(value: BigDecimal) {
    this.set("close", Value.fromBigDecimal(value));
  }

  get high(): BigDecimal {
    let value = this.get("high");
    return value!.toBigDecimal();
  }

  set high(value: BigDecimal) {
    this.set("high", Value.fromBigDecimal(value));
  }

  get low(): BigDecimal {
    let value = this.get("low");
    return value!.toBigDecimal();
  }

  set low(value: BigDecimal) {
    this.set("low", Value.fromBigDecimal(value));
  }

  get volumeFrom(): BigDecimal {
    let value = this.get("volumeFrom");
    return value!.toBigDecimal();
  }

  set volumeFrom(value: BigDecimal) {
    this.set("volumeFrom", Value.fromBigDecimal(value));
  }

  get volumeTo(): BigDecimal {
    let value = this.get("volumeTo");
    return value!.toBigDecimal();
  }

  set volumeTo(value: BigDecimal) {
    this.set("volumeTo", Value.fromBigDecimal(value));
  }

  get volume(): BigDecimal {
    let value = this.get("volume");
    return value!.toBigDecimal();
  }

  set volume(value: BigDecimal) {
    this.set("volume", Value.fromBigDecimal(value));
  }
}

export class ChartFunding extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ChartFunding entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ChartFunding must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChartFunding", id.toString(), this);
    }
  }

  static load(id: string): ChartFunding | null {
    return changetype<ChartFunding | null>(store.get("ChartFunding", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get interval(): i32 {
    let value = this.get("interval");
    return value!.toI32();
  }

  set interval(value: i32) {
    this.set("interval", Value.fromI32(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get open(): BigDecimal {
    let value = this.get("open");
    return value!.toBigDecimal();
  }

  set open(value: BigDecimal) {
    this.set("open", Value.fromBigDecimal(value));
  }

  get close(): BigDecimal {
    let value = this.get("close");
    return value!.toBigDecimal();
  }

  set close(value: BigDecimal) {
    this.set("close", Value.fromBigDecimal(value));
  }

  get high(): BigDecimal {
    let value = this.get("high");
    return value!.toBigDecimal();
  }

  set high(value: BigDecimal) {
    this.set("high", Value.fromBigDecimal(value));
  }

  get low(): BigDecimal {
    let value = this.get("low");
    return value!.toBigDecimal();
  }

  set low(value: BigDecimal) {
    this.set("low", Value.fromBigDecimal(value));
  }

  get type(): string {
    let value = this.get("type");
    return value!.toString();
  }

  set type(value: string) {
    this.set("type", Value.fromString(value));
  }

  get volumeFrom(): BigDecimal | null {
    let value = this.get("volumeFrom");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set volumeFrom(value: BigDecimal | null) {
    if (!value) {
      this.unset("volumeFrom");
    } else {
      this.set("volumeFrom", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get volumeTo(): BigDecimal | null {
    let value = this.get("volumeTo");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set volumeTo(value: BigDecimal | null) {
    if (!value) {
      this.unset("volumeTo");
    } else {
      this.set("volumeTo", Value.fromBigDecimal(<BigDecimal>value));
    }
  }
}

export class DelegateApprovalChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DelegateApprovalChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DelegateApprovalChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegateApprovalChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): DelegateApprovalChanged | null {
    return changetype<DelegateApprovalChanged | null>(
      store.get("DelegateApprovalChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get delegateApproval(): Bytes {
    let value = this.get("delegateApproval");
    return value!.toBytes();
  }

  set delegateApproval(value: Bytes) {
    this.set("delegateApproval", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FundingPaymentSettled extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save FundingPaymentSettled entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type FundingPaymentSettled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FundingPaymentSettled", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): FundingPaymentSettled | null {
    return changetype<FundingPaymentSettled | null>(
      store.get("FundingPaymentSettled", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get fundingPayment(): BigInt {
    let value = this.get("fundingPayment");
    return value!.toBigInt();
  }

  set fundingPayment(value: BigInt) {
    this.set("fundingPayment", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class LiquidityChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LiquidityChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type LiquidityChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LiquidityChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): LiquidityChanged | null {
    return changetype<LiquidityChanged | null>(
      store.get("LiquidityChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get maker(): Bytes {
    let value = this.get("maker");
    return value!.toBytes();
  }

  set maker(value: Bytes) {
    this.set("maker", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get quoteToken(): Bytes {
    let value = this.get("quoteToken");
    return value!.toBytes();
  }

  set quoteToken(value: Bytes) {
    this.set("quoteToken", Value.fromBytes(value));
  }

  get lowerTick(): i32 {
    let value = this.get("lowerTick");
    return value!.toI32();
  }

  set lowerTick(value: i32) {
    this.set("lowerTick", Value.fromI32(value));
  }

  get upperTick(): i32 {
    let value = this.get("upperTick");
    return value!.toI32();
  }

  set upperTick(value: i32) {
    this.set("upperTick", Value.fromI32(value));
  }

  get base(): BigInt {
    let value = this.get("base");
    return value!.toBigInt();
  }

  set base(value: BigInt) {
    this.set("base", Value.fromBigInt(value));
  }

  get quote(): BigInt {
    let value = this.get("quote");
    return value!.toBigInt();
  }

  set quote(value: BigInt) {
    this.set("quote", Value.fromBigInt(value));
  }

  get liquidity(): BigInt {
    let value = this.get("liquidity");
    return value!.toBigInt();
  }

  set liquidity(value: BigInt) {
    this.set("liquidity", Value.fromBigInt(value));
  }

  get quoteFee(): BigInt {
    let value = this.get("quoteFee");
    return value!.toBigInt();
  }

  set quoteFee(value: BigInt) {
    this.set("quoteFee", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnershipTransferred", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Paused extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Paused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Paused must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Paused", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Paused | null {
    return changetype<Paused | null>(store.get("Paused", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PlatformFundChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PlatformFundChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PlatformFundChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PlatformFundChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PlatformFundChanged | null {
    return changetype<PlatformFundChanged | null>(
      store.get("PlatformFundChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get platformFundArg(): Bytes {
    let value = this.get("platformFundArg");
    return value!.toBytes();
  }

  set platformFundArg(value: Bytes) {
    this.set("platformFundArg", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PositionChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PositionChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PositionChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PositionChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PositionChanged | null {
    return changetype<PositionChanged | null>(
      store.get("PositionChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get exchangedPositionSize(): BigDecimal {
    let value = this.get("exchangedPositionSize");
    return value!.toBigDecimal();
  }

  set exchangedPositionSize(value: BigDecimal) {
    this.set("exchangedPositionSize", Value.fromBigDecimal(value));
  }

  get exchangedPositionNotional(): BigDecimal {
    let value = this.get("exchangedPositionNotional");
    return value!.toBigDecimal();
  }

  set exchangedPositionNotional(value: BigDecimal) {
    this.set("exchangedPositionNotional", Value.fromBigDecimal(value));
  }

  get swappedPrice(): BigDecimal {
    let value = this.get("swappedPrice");
    return value!.toBigDecimal();
  }

  set swappedPrice(value: BigDecimal) {
    this.set("swappedPrice", Value.fromBigDecimal(value));
  }

  get marketPriceAfter(): BigDecimal {
    let value = this.get("marketPriceAfter");
    return value!.toBigDecimal();
  }

  set marketPriceAfter(value: BigDecimal) {
    this.set("marketPriceAfter", Value.fromBigDecimal(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }

  get openNotional(): BigInt {
    let value = this.get("openNotional");
    return value!.toBigInt();
  }

  set openNotional(value: BigInt) {
    this.set("openNotional", Value.fromBigInt(value));
  }

  get realizedPnl(): BigInt {
    let value = this.get("realizedPnl");
    return value!.toBigInt();
  }

  set realizedPnl(value: BigInt) {
    this.set("realizedPnl", Value.fromBigInt(value));
  }

  get sqrtPriceAfterX96(): BigInt {
    let value = this.get("sqrtPriceAfterX96");
    return value!.toBigInt();
  }

  set sqrtPriceAfterX96(value: BigInt) {
    this.set("sqrtPriceAfterX96", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PositionClosed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PositionClosed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PositionClosed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PositionClosed", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PositionClosed | null {
    return changetype<PositionClosed | null>(
      store.get("PositionClosed", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get closedPositionSize(): BigInt {
    let value = this.get("closedPositionSize");
    return value!.toBigInt();
  }

  set closedPositionSize(value: BigInt) {
    this.set("closedPositionSize", Value.fromBigInt(value));
  }

  get closedPositionNotional(): BigInt {
    let value = this.get("closedPositionNotional");
    return value!.toBigInt();
  }

  set closedPositionNotional(value: BigInt) {
    this.set("closedPositionNotional", Value.fromBigInt(value));
  }

  get openNotional(): BigInt {
    let value = this.get("openNotional");
    return value!.toBigInt();
  }

  set openNotional(value: BigInt) {
    this.set("openNotional", Value.fromBigInt(value));
  }

  get realizedPnl(): BigInt {
    let value = this.get("realizedPnl");
    return value!.toBigInt();
  }

  set realizedPnl(value: BigInt) {
    this.set("realizedPnl", Value.fromBigInt(value));
  }

  get closedPrice(): BigInt {
    let value = this.get("closedPrice");
    return value!.toBigInt();
  }

  set closedPrice(value: BigInt) {
    this.set("closedPrice", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PositionLiquidated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PositionLiquidated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PositionLiquidated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PositionLiquidated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PositionLiquidated | null {
    return changetype<PositionLiquidated | null>(
      store.get("PositionLiquidated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get trader(): Bytes {
    let value = this.get("trader");
    return value!.toBytes();
  }

  set trader(value: Bytes) {
    this.set("trader", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get positionNotional(): BigInt {
    let value = this.get("positionNotional");
    return value!.toBigInt();
  }

  set positionNotional(value: BigInt) {
    this.set("positionNotional", Value.fromBigInt(value));
  }

  get positionSize(): BigInt {
    let value = this.get("positionSize");
    return value!.toBigInt();
  }

  set positionSize(value: BigInt) {
    this.set("positionSize", Value.fromBigInt(value));
  }

  get liquidationFee(): BigInt {
    let value = this.get("liquidationFee");
    return value!.toBigInt();
  }

  set liquidationFee(value: BigInt) {
    this.set("liquidationFee", Value.fromBigInt(value));
  }

  get liquidator(): Bytes {
    let value = this.get("liquidator");
    return value!.toBytes();
  }

  set liquidator(value: Bytes) {
    this.set("liquidator", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Repeg extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Repeg entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Repeg must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Repeg", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Repeg | null {
    return changetype<Repeg | null>(store.get("Repeg", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get oldMarkPrice(): BigInt {
    let value = this.get("oldMarkPrice");
    return value!.toBigInt();
  }

  set oldMarkPrice(value: BigInt) {
    this.set("oldMarkPrice", Value.fromBigInt(value));
  }

  get newMarkPrice(): BigInt {
    let value = this.get("newMarkPrice");
    return value!.toBigInt();
  }

  set newMarkPrice(value: BigInt) {
    this.set("newMarkPrice", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class TrustedForwarderChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TrustedForwarderChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TrustedForwarderChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TrustedForwarderChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): TrustedForwarderChanged | null {
    return changetype<TrustedForwarderChanged | null>(
      store.get("TrustedForwarderChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get forwarder(): Bytes {
    let value = this.get("forwarder");
    return value!.toBytes();
  }

  set forwarder(value: Bytes) {
    this.set("forwarder", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class TrustedForwarderUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TrustedForwarderUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TrustedForwarderUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TrustedForwarderUpdated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): TrustedForwarderUpdated | null {
    return changetype<TrustedForwarderUpdated | null>(
      store.get("TrustedForwarderUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get trustedForwarder(): Bytes {
    let value = this.get("trustedForwarder");
    return value!.toBytes();
  }

  set trustedForwarder(value: Bytes) {
    this.set("trustedForwarder", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Unpaused extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Unpaused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Unpaused must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Unpaused", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Unpaused | null {
    return changetype<Unpaused | null>(store.get("Unpaused", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AccountBalanceChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AccountBalanceChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AccountBalanceChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccountBalanceChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): AccountBalanceChanged | null {
    return changetype<AccountBalanceChanged | null>(
      store.get("AccountBalanceChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get accountBalance(): Bytes {
    let value = this.get("accountBalance");
    return value!.toBytes();
  }

  set accountBalance(value: Bytes) {
    this.set("accountBalance", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ClearingHouseChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ClearingHouseChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ClearingHouseChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ClearingHouseChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ClearingHouseChanged | null {
    return changetype<ClearingHouseChanged | null>(
      store.get("ClearingHouseChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get clearingHouse(): Bytes {
    let value = this.get("clearingHouse");
    return value!.toBytes();
  }

  set clearingHouse(value: Bytes) {
    this.set("clearingHouse", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FundingUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FundingUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type FundingUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FundingUpdated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): FundingUpdated | null {
    return changetype<FundingUpdated | null>(
      store.get("FundingUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get markTwap(): BigDecimal {
    let value = this.get("markTwap");
    return value!.toBigDecimal();
  }

  set markTwap(value: BigDecimal) {
    this.set("markTwap", Value.fromBigDecimal(value));
  }

  get indexTwap(): BigDecimal {
    let value = this.get("indexTwap");
    return value!.toBigDecimal();
  }

  set indexTwap(value: BigDecimal) {
    this.set("indexTwap", Value.fromBigDecimal(value));
  }

  get longPositionSize(): BigDecimal {
    let value = this.get("longPositionSize");
    return value!.toBigDecimal();
  }

  set longPositionSize(value: BigDecimal) {
    this.set("longPositionSize", Value.fromBigDecimal(value));
  }

  get shortPositionSize(): BigDecimal {
    let value = this.get("shortPositionSize");
    return value!.toBigDecimal();
  }

  set shortPositionSize(value: BigDecimal) {
    this.set("shortPositionSize", Value.fromBigDecimal(value));
  }

  get shortDeltaRatio(): BigDecimal {
    let value = this.get("shortDeltaRatio");
    return value!.toBigDecimal();
  }

  set shortDeltaRatio(value: BigDecimal) {
    this.set("shortDeltaRatio", Value.fromBigDecimal(value));
  }

  get longDeltaRatio(): BigDecimal {
    let value = this.get("longDeltaRatio");
    return value!.toBigDecimal();
  }

  set longDeltaRatio(value: BigDecimal) {
    this.set("longDeltaRatio", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class MaxTickCrossedWithinBlockChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save MaxTickCrossedWithinBlockChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type MaxTickCrossedWithinBlockChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "MaxTickCrossedWithinBlockChanged",
        id.toBytes().toHexString(),
        this
      );
    }
  }

  static load(id: Bytes): MaxTickCrossedWithinBlockChanged | null {
    return changetype<MaxTickCrossedWithinBlockChanged | null>(
      store.get("MaxTickCrossedWithinBlockChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    return value!.toBytes();
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get maxTickCrossedWithinBlock(): i32 {
    let value = this.get("maxTickCrossedWithinBlock");
    return value!.toI32();
  }

  set maxTickCrossedWithinBlock(value: i32) {
    this.set("maxTickCrossedWithinBlock", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ExchangeOwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ExchangeOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ExchangeOwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "ExchangeOwnershipTransferred",
        id.toBytes().toHexString(),
        this
      );
    }
  }

  static load(id: Bytes): ExchangeOwnershipTransferred | null {
    return changetype<ExchangeOwnershipTransferred | null>(
      store.get("ExchangeOwnershipTransferred", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}
